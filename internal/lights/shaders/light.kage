//kage:unit pixels
package main

var LightPositions [16]vec2
var LightRadii     [16]float
var LightInnerRadiusFactors [16]float
var LightMaxBrightness [16]float
var LightColors    [16]vec3
var NightTint vec3
var ExtraDarken float

func Fragment(dstPos vec4, srcPos vec2, _ vec4) vec4 {
    col := imageSrc0At(srcPos)
    if col.a == 0 {
        return vec4(0)
    }
    closestLightDist := 10000.0
    closestCoreRadius := 0.0
    pix := dstPos.xy
    // Accumulate light contributions in one pass
    total := vec3(0, 0, 0)
    for i := 0; i < 16; i++ {
        if LightRadii[i] <= 0.0 {
            break // once a zero is hit, we are at the end of the lights
        }
        maxBrightness := LightMaxBrightness[i]
        if maxBrightness <= 0.0 {
            continue // skip lights with no brightness
        }

        outerRadius := LightRadii[i]
        innerRadius := LightRadii[i] * LightInnerRadiusFactors[i]
        dist := distance(LightPositions[i], pix)
        att := 0.0

        if dist < innerRadius {
            att = maxBrightness
        } else if dist < outerRadius {
            // between inner and outer radius, fall off linearly
            att = 1.0 - (dist - innerRadius) / (outerRadius - innerRadius)
            att = clamp(att, 0.0, maxBrightness)
        } else {
            att = 0.0
        }

        // --- Add a bright core at the center ---
        coreRadius := innerRadius * 0.05
        strengthFactor := maxBrightness * 2.0
        core := exp(-pow(dist / coreRadius, 2.0)) * strengthFactor
        // the 2.0 here is for a "gaussian" falloff

        total += (att + core) * LightColors[i]

        if dist < closestLightDist {
            closestLightDist = dist
            closestCoreRadius = coreRadius
        }
    }

    maxTotal := 1.0
    centerMaxTotal := 1.8
    smoothRange := closestCoreRadius * 2 // distance over which brightness fades to normal

    // smoothstep: returns 0 at x<=0, 1 at x>=1
    t := clamp(closestLightDist / smoothRange, 0.0, 1.0)
    maxTotal = mix(centerMaxTotal, 1.0, t)
    total = clamp(total, 0.0, maxTotal)

    // blend between night tint and normal color based on total light
    dark := col.rgb * NightTint

    if ExtraDarken > 0.0 {
        // boost contrast of dark areas a bit
        extraDark := pow(dark, vec3(1.8))

        // bias towards keeping bright areas more visible
        luma := dot(col.rgb, vec3(0.299, 0.587, 0.114))
        extraDark = mix(extraDark, extraDark * 1.2, luma)

        // blend with original dark color based on ExtraDarken uniform
        dark = mix(dark, extraDark, ExtraDarken)
    }

    col.rgb = mix(dark, col.rgb, total)
    return col
}
