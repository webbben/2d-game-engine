//kage:unit pixels
package main

var LightPositions [16]vec2
var LightRadii     [16]float
var LightInnerRadiusFactors [16]float
var LightColors    [16]vec3
var NightTint vec3
var ExtraDarken float

func Fragment(dstPos vec4, srcPos vec2, _ vec4) vec4 {
    maxBrightness := 0.8 // TODO make this a uniform

    col := imageSrc0At(srcPos)
    if col.a == 0 {
        return vec4(0)
    }
    pix := dstPos.xy
    // Accumulate light contributions in one pass
    total := vec3(0, 0, 0)
    for i := 0; i < 16; i++ {
        if LightRadii[i] <= 0.0 {
            break // once a zero is hit, we are at the end of the lights
        }

        outerRadius := LightRadii[i]
        innerRadius := LightRadii[i] * LightInnerRadiusFactors[i]
        dist := distance(LightPositions[i], pix)
        att := 0.0

        if dist < innerRadius {
            att = maxBrightness
        } else if dist < outerRadius {
            // between inner and outer radius, fall off linearly
            att = 1.0 - (dist - innerRadius) / (outerRadius - innerRadius)
            att = clamp(att, 0.0, maxBrightness)
        } else {
            att = 0.0
        }

        total += att * LightColors[i]
    }

    // blend between night tint and normal color based on total light
    total = clamp(total, 0.0, 1.0)
    dark := col.rgb * NightTint

    if ExtraDarken > 0.0 {
        // boost contrast of dark areas a bit
        extraDark := pow(dark, vec3(1.8))

        // bias towards keeping bright areas more visible
        luma := dot(col.rgb, vec3(0.299, 0.587, 0.114))
        extraDark = mix(extraDark, extraDark * 1.2, luma)

        // blend with original dark color based on ExtraDarken uniform
        dark = mix(dark, extraDark, ExtraDarken)
    }

    col.rgb = mix(dark, col.rgb, total)
    return col
}
