//kage:unit pixels
package main

var LightPositions [16]vec2
var LightRadii     [16]float
var LightInnerRadiusFactors [16]float
var LightCoreRadiusFactors [16]float
var LightMaxBrightness [16]float
var LightColors    [16]vec3
var NightTint vec3
var ExtraDarken float
var MaxBrightness float // overall max brightness, when not influenced by light cores


func Fragment(dstPos vec4, srcPos vec2, _ vec4) vec4 {
    col := imageSrc0At(srcPos)
    if col.a == 0 {
        return vec4(0)
    }
    closestLightDist := 10000.0
    closestCoreRadius := 0.0
    pix := dstPos.xy
    // Accumulate light contributions in one pass
    total := vec3(0, 0, 0)
    for i := 0; i < 16; i++ {
        if LightRadii[i] <= 0.0 {
            break // once a zero is hit, we are at the end of the lights
        }
        maxBrightness := LightMaxBrightness[i]
        if maxBrightness <= 0.0 {
            continue // skip lights with no brightness
        }

        outerRadius := LightRadii[i]
        innerRadius := LightRadii[i] * LightInnerRadiusFactors[i]
        dist := distance(LightPositions[i], pix)
        att := 0.0

        if dist < innerRadius {
            att = maxBrightness
        } else if dist < outerRadius {
            // between inner and outer radius, fall off linearly
            att = 1.0 - (dist - innerRadius) / (outerRadius - innerRadius)
            att = clamp(att, 0.0, maxBrightness)
        } else {
            att = 0.0
        }

        // --- Add a bright core at the center ---
        core := 0.0
        coreRadius := LightRadii[i] * LightCoreRadiusFactors[i]
        if coreRadius > 0.0 {
            strengthFactor := maxBrightness * 2.0
            core = exp(-pow(dist / coreRadius, 2.0)) * strengthFactor
            // the 2.0 here is for a "gaussian" falloff
        }

        total += (att + core) * LightColors[i]

        if core > 0.0 && dist < closestLightDist {
            closestLightDist = dist
            closestCoreRadius = coreRadius
        }
    }

    if closestCoreRadius == 0.0 {
        // no light cores affecting this pixel, use normal max
        total = clamp(total, 0.0, MaxBrightness)
    } else {
        // adjust max brightness based on distance to closest core
        maxTotal := 1.0
        centerMaxTotal := 1.8
        smoothRange := closestCoreRadius * 2 // distance over which brightness fades to normal

        // smoothstep from centerMaxTotal to MaxBrightness based on distance to core
        t := clamp(closestLightDist / smoothRange, 0.0, 1.0)
        maxTotal = mix(centerMaxTotal, MaxBrightness, t)
        total = clamp(total, 0.0, maxTotal)
    }

    // blend between night tint and normal color based on total light
    dark := col.rgb * NightTint

    if ExtraDarken > 0.0 {
        // boost contrast of dark areas a bit
        extraDark := pow(dark, vec3(1.8))

        // bias towards keeping bright areas more visible
        luma := dot(col.rgb, vec3(0.299, 0.587, 0.114))
        extraDark = mix(extraDark, extraDark * 1.2, luma)

        // blend with original dark color based on ExtraDarken uniform
        dark = mix(dark, extraDark, ExtraDarken)
    }

    col.rgb = mix(dark, col.rgb, total)
    return col
}
